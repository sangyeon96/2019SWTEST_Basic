# 2019SWTEST_Basic

[TOC]

## 수학

### 나머지 연산 [10430]

ex) 1,000,000,007으로 9를 나눈 나머지를 출력하라.

int(4 bytes)의 최대값: 2^31-1

long long(8 bytes)의 최대값: 2^63-1

이 자료형을 넘어가는 숫자의 경우?

```c++
(A+B) % C = (A % C + B % C) % C

(A-B) % C = ( (A % C) - (B % C) + C) % C

(AxB) % C = ((A % C) x (B % C) ) % C
```

#### 페르마의 소정리(드물게 쓰인다)

(A/B) % C = (A x B^C-2) % C(C는 소수, A, B는 서로소)



### 최대공약수 [2609, 9613]

최대공약수(GCD: Greatest Common Divisor)

=> 유클리드호제법을 활용하면 빠르다.

#### 유클리드 호제법

a를 b로 나눈 나머지를 r이라고 했을 때, GCD(a, b) = GCD(b, r)과 같다.

r이 0이면 그 때 b가 최대공약수 이다.

ex) GCD(24, 16) = GCD(16, 8) = GCD(8, 0) = 8

##### 재귀함수 활용

```c++
int gcd(int a, int b) {
  if(b == 0) {
    return a;
  } else {
    return gcd(b, a%b);
  }
}
```

시간복잡도는 O(log N)이다.

##### 반복문 활용

```c++
int gcd(int a, int b) {
  while(b != 0) {
    int r = a % b;
    a = b;
    b = r;
  }
  return a;
}
```

시간복잡도는 재귀함수 활용했을 시와 같이 O(log N)이다.

#### 세 수 이상의 최대공약수

GCD(a, b, c) = GCD(GCD(a, b), c)

### 최소공배수 [1934]

주어진 수의 곱 / GCD = 최소공배수

### 소수(Prime Number)

약수가 1과 자기자신 밖에 없는 수.

#### 소수와 관련된 알고리즘

1. 어떤 수 N이 소수인지 아닌지 판별하는 방법
2. N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법

##### 1. 어떤 수 N이 소수인지 아닌지 판별하는 방법 [1978]

###### 방법1: O(N)

N이 소수가 되려면, 2보다 크거나 같고, **N/2보다 작거나 같은 자연수로 나누어 떨어지면 안된다.**

N = a x b

a = 2라고 하면, b = N/2여야 한다. N은 2 또는 N/2로 나누어 떨어지므로 안된다.

a = 3이라고 하면, b = N/3여야 한다. N은 3 또는 N/3으로 나누어 떨어지면 안된다.

N/3 < N/2이므로 2부터 N/2까지만 확인해도 소수인지 아닌지 판별할 수 있다.

```c++
bool prime(int n) {
  if(n < 2) {
    return false;
  }
  else {
    for (int i = 2; i <= n/2; i++) {
      if(n % i == 0) {
        return false;
      }
    }
    return true;
  }
}
```

###### 방법2: O(root N)

N이 소수가 되려면, 2보다 크거나 같고, **루트N보다 작거나 같은 자연수로 나누어 떨어지면 안된다.**

N = a x b

a <= root N이라고 하면,  b > root N이어야 한다.

고로 a, b 모두 root N보다 클 수는 없다.

그러므로 2부터 root N까지만 확인해도 소수인지 아닌지 판별할 수 있다.

ex 1) 24: 1, 2, 3, 4 / 6, 8, 12, 24

root 24 = 4.xx

4까지만 확인해도 소수인지 아닌지 알 수 있다.

ex 2) 36: 1, 2, 3, 4 / 6 / 9, 12, 18, 36

root 36 = 6

6까지만 확인해도 소수인지 아닌지 알 수 있다. 

```c++
bool prime(int n) {
  if(n < 2) {
    return false;
  }
  else {
    for(int i = 2; i*i <= n; i++) {
      if(n % i == 0) {
        return false;
      }
    }
    return true;
  }
}
```

##### 2. N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법

###### 에라토스테네스의 체: O(N log log N) by Prime Harmonic Series [1929]

1. 2부터 N까지 모든 수를 써놓는다.
2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
3. 그 수는 소수이다.
4. 이제 그 수의 배수를 모두 지운다.

```c++
int prime[100]; // 소수 저장
int pn=0; // 소수의 개수
bool check[101]; // 지워졌으면 true
int n = 100; // 100까지 소수
for(int i = 2; i <= n; i++) {
  if(check[i] == false) {
    prime[pn++] = i;
    for(int j = i*i; j <= n; j+=i) {
      check[j] = true;
    }
  }
}
```

###### 골드바흐의 추측 [6588]

2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다.

=> 5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다.



## 브루트 포스

모든 경우의 수를 다 해보는 것.

ex) 비밀번호가 4자리 => 0000부터 9999까지 다 입력(경우의 수 10000가지)

1. 문제의 가능한 경우의 수를 계산해본다.
2. 가능한 모든 방법을 다 만들어본다. (그냥 다 해보기 [2309, 1476, 14500] , for문 [9095] , 순열 [10972, 10973, 10974, 10819, 10971, 6603, 14888] , 재귀 호출 [1182, 14501, 15658] , 비트마스크 사용 [11723] 등)
3. 각각의 방법을 이용해 답을 구해본다.



> 재귀호출[1182]  풀이 굉장히 간결하다.. 난 순열로 풀어서 매우 복잡한데.. 본받아야지..



## 그래프

**G(V, E)** : Graph(Vertex, Edge)

**경로(Path)** : 정점 A에서 B로 가는 경로

가중치가 제일 적은 경로가 최단 경로.

**사이클(Cycle)** : 정점 A에서 다시 A로 돌아오는 경로

**단순 경로/사이클** : 같은 정점을 두 번 이상 방문하지 않는 경로/사이클

방향 그래프의 경우에는 In-degree, Out-degree로 나누어서 **차수(Degree)**를 계산한다.

[13023]

### 인접행렬(Adjacency-matrix)

공간복잡도 O(V^2). 

임의의 두 정점 u, v가 주어졌을 때, u->v 또는 v->u가 존재하는지 찾을 때 시간복잡도 O(1), 정점 X와 연결된 모든 간선을 찾을 시, 시간복잡도 O(V)

간선이 있으면 배열 값이 1, 없으면 배열 값이 0

가중치가 있다면 배열 값이 가중치, 없으면 배열 값이 0

### 인접리스트(Adjacency-list)

공간복잡도 O(E). 정점 X와 연결된 모든 간선을 찾을 시, 시간복잡도 O(차수)

A[i] = i와 연결된 정점을 리스트로 포함하고 있음

리스트는 크기를 동적으로 변경할 수 있어야 한다. => C++은 vector를 활용하여 인접리스트를 구현한다.

ex) A[1] = 2 5

1과 2, 5가 연결되어 있음

가중치가 있다면 ex) A[1] = (2, 2) (5, 7) 형태로 가중치도 같이 저장

### 간선리스트(Edge-list)

ex) 정점의 개수는 5개이고, 간선은 (1, 2), (1, 5), (3, 4), (3, 5)가 연결되어 있다.

E[0] = 1 2

E[1] = 1 5

E[2] = 3 4

E[3] = 3 5

이런 식으로 모든 간선을 저장한다. 그리고 각 정점의 차수를 저장한다.

cnt[0] = 0

cnt[1] = 2

cnt[2] = 0

cnt[3] = 2

cnt[4] = 0

cnt[5] = 0

그리고 누적한 결과를 저장한다.

cnt[0] = 0

cnt[1] = 2

cnt[2] = 0

cnt[3] = 4

cnt[4] = 0

cnt[5] = 0

간선리스트를 활용하면 정점 X와 연결된 모든 간선을 찾을 시 index를 활용하여 몇번 index부터 몇번 index까지 정점 X와 연결된 간선인지 알 수 있다.

ex) cnt[1] = 2이므로 E[0], E[1]에는 정점 1과 연결된 간선 정보가 있고, cnt[3] = 4이므로 E[2], E[3]에는 정점 3과 연결된 간선 정보가 있다.

## 그래프의 탐색(DFS, BFS)

시작점 X부터 시작해서 모든 정점을 1번씩 순회하는 것.

### DFS(깊이 우선 탐색)

**Stack**을 이용해서 갈 수 있는 만큼 최대한 많이 가고, 갈 수 없으면 이전 정점으로 돌아간다.

모든 정점을 1회씩 순회하므로 check[i]를 두어 방문했을 경우 1로 표시한다.

방문했을 시, Stack에 넣는다. Stack이 비면 탐색이 종료된다.

주로 재귀함수를 이용한다.

### BFS(너비 우선 탐색)

지금 위치에서 갈 수 있는 것을 모두 **Queue**에 넣는다. Queue에 넣을 때 방문했다고 체크해야 한다.

Queue가 비면 탐색이 종료된다.

## 연결 요소(Connected Component)

나누어진 각각의 그래프를 연결 요소라고 한다.

## 이분 그래프(Bipartite Graph)

그래프를 A와 B로 나눌 수 있으면 이분 그래프라고 한다.

A에 포함되어 있는 정점끼리 연결된 간선이 없고, B에 포함되어 있는 정점끼리 연결된 간선이 없다.

A는 빨간 색, B는 파란 색으로 색칠한다. (현재 정점이 빨간 색이면 방문한 정점은 파란 색, 현재 정점이 파란 색이면 방문한 정점은 빨간 색으로 표시한다.)

=> 탐색(DFS or BFS)하면서 색이 다른 지를 비교하여 이분 그래프인지 아닌지 확인할 수 있다.